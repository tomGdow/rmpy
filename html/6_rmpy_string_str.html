<!DOCTYPE html> 
<html lang="en">

  <head>
    <meta charset="utf-8"/>
    <title>[STRING]</title>
    <link rel="icon" href="http://xu/tgdfiles/icon/bonnie.ico"/>
    <style>
div {
  color: black;
}
    </style>
  </head>

  <body>
    <div class="container">
      <header>
        string
      </header>
      <div class="counter">xx</div>
      <main>
        <dl>
          <dt>string/str</dt>
          <dd>String values must be enclosed within quotes</dd>
          <dd>In python, the <mark>string data types are immutable</mark>. </dd>
          <dd>Which means a string value cannot be updated</dd>
          <dd>but sometimes string <em>is</em> mutable (see below!)</dd>
        </dl>
      </main>
      <div class="syntax">
        <details>
          <summary>Some String Methods</summary>
          <dl>
            <dt><code>str.find(sub[, start[, end]])</code></dt>
            <dd>Return the <mark>lowest index</mark> in the string where
            <code>sub</code> is found within the slice <code>s[start:end]</code>.
            </dd> 
            <dd>Optional arguments <code>start</code> and <code>end</code> are
            interpreted as in <code>slice</code> notation.</dd> 
            <dd>Return -1 if <code>sub</code> is not found (contrast with
            <code>str.index()</code>)
            </dd>

            <dd>The <code>find()</code> method should be used only if you need to
            know the position of sub. </dd>   
            <dd>To check if sub is a substr<code>in</code>g or not, use the
 <code>in</code>
            operator:</dd>
            <dd><pre> 
    'Py' in 'Python'
    True
            </pre></dd>   


            <dd>
            <pre> 
            str="thomas Manure"
            str.find('om')    //     2
            str.find('omm')   //    -1
            str.index('om')   //     2
            str.index('omm')
            //  Traceback (most recent call last):
            //    File "&lt;pyshell#4&gt;", line 1, in &lt;module&gt;
            //      str.index('omm')
            //  ValueError: substring not found
            </pre>
            </dd>   
            <dd><pre> 
            str ="The apple is red and the berry is blue"

            str.find('is')             //     10
            str.rfind('is')            //     31
            str[str.rfind('is')]       //     'i'
            str[str.rfind('is'):]      //     'is blue'
            str[:str.rfind('is')]      //     'The apple is red and the berry '

            import re
            [m.start() for m in re.finditer('is', str)]    //     [10, 31]
            </pre><dd>  

            <dt><code>str.rfind(sub[, start[, end]])</code></dt>

            <dd>Return the <mark>highest index</mark> in the string where substring
            <code>sub</code> is found, such that <code>sub</code> is contained
            within <code>s[start:end]</code>.</dd> 

            <dd>Optional arguments <code>start</code> and <code>end</code>
            are interpreted as in slice notation.</dd>   
            <dd>Return -1 on failure</dd>
            <dd><pre> 

    str="tom is a man and tom is a coder"

    str.find('is', 0, -1)    //     4
    str.rfind('is')          //     21
    str[str.find('is'):]     //     'is a man and tom is a coder'
    str[str.rfind('is'):]    //     'is a coder'

            </pre></dd>   


            <dt><code>str.index(sub[, start[, end]])</code></dt>

            <dd>Like <code>find()</code>, but raise <code>ValueError</code> when
            the substring is not found.</dd>


            <dt><code>str.rindex(sub[, start[, end]])</code></dt>

            <dd>Like <code>rfind()</code> but raises <code>ValueError</code>
            when the substring <code>sub</code> is not found.</dd>

            <dt>raw string</dt>
            <dd><code>r"thomas\t\n"</code></dd>      

            <dt><code>str.isalnum()</code></dt>

            <dd>
            Return <code>True</code> if all characters in the string are
            alphanumeric and there is at least one character, <code>False</code>
            otherwise.</dd> 
            <dd>A character <code>c</code> is alphanumeric if one of the following
            returns <code>True</code>:
            </dd>
            <dd>
            <ul>  
              <li><code>c.isalpha()</code></li>
              <li><code>c.isdecimal()</code></li>
              <li><code>c.isdigit()</code></li>
              <li><code>c.isnumeric()</code></li>
            </ul>                                            
            </dd>

            <dd>
            <pre>
    "123".isalnum()    //   True
    "abc".isalnum()    //   True
    "abc-".isalnum()   //   False
    "abc-".isalpha()   //   False
            </pre>
            </dd>

            <dt><code>str.isalpha()</code></dt>

            <dd>Return <code>True</code> if all characters in the string are alphabetic
            and there is at least one character, <code>False</code> otherwise.</dd> 

            <dd>Alphabetic characters are those characters defined in the Unicode
            character database as "Letter"</dd>

            <dt><code>str.isdecimal()</code></dt>

            <dd>Return <code>True</code> if all characters in the string are decimal
            characters and there is at least one character, <code>False</code>
            otherwise.</dd>
            <dd>Decimal characters are those that can be used to form
            numbers in base 10</dd>

            <dd><pre> 
    '123.4'.isdecimal()    //   False
    '123.4'.isdigit()      //   False
            </pre></dd>   

            <dt><code>str.isdigit()</code></dt> 

            <dd>Return <code>True</code> if all
            characters in the string are digits and there is at least one character,
            <code>False</code> otherwise.</dd>
            <dd>Digits include decimal characters
            and digits that need special handling, such as the compatibility
            superscript digits.</dd>
            <dd>This covers digits which cannot be used to
            form numbers in base 10, like the Kharosthi numbers.</dd> 

            <dt><code>str.isidentifier()</code></dt>

            <dd>Return <code>True</code> if the string is a valid identifier
            according to the language definition</dd>

            <dd>Call <code>keyword.iskeyword()</code> to test whether string
            <code>s</code> is a reserved identifier, such as <code>def</code> and 
            <code>class</code>.</dd>  
            <dt><code>str.upper()</code></dt>
            <dt><code>str.lower()</code></dt>
            <dt><code>str.swapcase()</code></dt>
            <dd>Return a copy of the string with uppercase characters converted to
            lowercase and vice versa.</dd> 
            <dd>Note that it is not necessarily true that
            <code>s.swapcase().swapcase() == s</code>.</dd>

            <dt><code>str.strip([chars])</code></dt>

            <dd>Return a copy of the string with the leading and trailing
            characters removed.</dd> 
            <dd>The <code>chars</code> argument is a string specifying the set of
            characters to be removed.</dd> 
            <dd>If omitted or <code>None</code>, the chars argument defaults to
            removing <code>whitespace</code>.</dd> 
            <dd>The <code>chars</code> argument is not a prefix or suffix; rather,
            all combinations of its values are stripped</dd>

            <dd>The outermost leading and trailing <code>chars</code> argument
            values are stripped from the string.</dd> 
            <dd>Characters are removed from the leading end until reaching a string
            character <mark>that is not contained</mark> in the set of characters
            in <code>chars</code>.</dd> 
            <dd>A similar action takes place on the trailing end.</dd>
            <dd><pre> 
    spstr="    spacious    "
    spstr.strip()               //   'spacious'
    wwwstr="www.example.com"
    wwwstr.strip('cmowz.')      //   'example'
    wwwstr2="www.exa.mple.com"
    wwwstr2.strip('cmowz.')     //   'exa.mple'   // !Note
            </pre><dd>  
            <dt><code>str.rstrip([chars])</code></dt>
            <dt><code>str.lstrip([chars])</code></dt>

            <dt><code>str.capitalize()</code></dt>
            <dd>Return a copy of the string with its first character capitalized
            and the rest lowercased.</dd>

            <dd>Changed in version 3.8: The first character is now put into
            titlecase rather than uppercase.</dd> 
            <dd>This means that characters like digraphs will only have their first
            letter capitalized, instead of the full character.</dd>
            <dd>  <pre> 
      thomas manure".capitalize()    //   'Thomas manure'
            </pre></dd>   

            <dt><code>str.istitle()</code></dt>

            <dd>Return <code>True</code> if the string is a <code>titlecased</code>
            string and there is at least one character</dd>
            <dd>For example, uppercase characters may only follow uncased
            characters and lowercase characters only cased ones.</dd> 
            <dd>Return <code>False</code> otherwise.</dd>

            <dd>
            <pre> 
        'Thomas manure'.istitle()    //   False
        'Thomas Manure'.istitle()    //   True
        'ThOmAs Manure'.istitle()    //   False
        'ThomsManure'.istitle()      //   False
            </pre>
            </dd>   

            <dt><code>str.center(width[, fillchar])</code></dt>

            <dd>Return centered in a string of length <code>width</code>.</dd>    
            <dd>Padding is done using the specified <code>fillchar</code>
            (default is an ASCII space).</dd> 
            <dd>The original string is returned if width is less than or equal
            to <code>len(s)</code>.</dd>

            <dd><pre>
'tom'.center(9, '*')    //  '***tom***'
'tom'.center(9, ' ')    //  '   tom   '
'tom'.center(9)         //  '   tom   '   // Default is ASCII space
            </pre></dd>   

            <dt><code>str.split(sep=None, maxsplit=-1)</code></dt> 

            <dd>Return a list of the words in the string, using <code>sep</code>
            as the delimiter string.</dd> 
            <dd>If <code>maxsplit</code> is given, at most <code>maxsplit</code>
            splits are done (thus, the list will have at most
            <code>maxsplit+1</code> elements).</dd> 
            <dd>If <code>maxsplit</code> is not specified or -1, then there is no
            limit on the number of splits (all possible splits are made).</dd>
            <dd>If <code>sep</code> is given, consecutive delimiters are not
            grouped together and are deemed to delimit empty strings</dd> 
            <dd>For example, <code>'1,,2'.split(',')</code> returns
            <code>['1', '', '2'])</code></dd> 
            <dd>The <code>sep</code> argument may consist of multiple characters
            (for example, <code>'1&lt;&gt;2&lt;&gt;3'.split('&lt;&gt;')</code> returns
            <code>['1', '2', '3'])</code>.</dd> 

            <dd>Splitting an empty string with a specified separator returns
            <code>['']</code></dd>   

            <dd>If <code>sep</code> is not specified or is <code>None</code>,
            a different splitting algorithm is applied</dd>
            <dd>Runs of consecutive whitespace are regarded as a single separator,
            and the result will contain no empty strings at the start or end if
            the string has leading or trailing whitespace.</dd> 
            <dd>Consequently, splitting an empty string or a string consisting of
            just whitespace with a <code>None</code> separator returns<code>[]</code>
            </dd>

            <dd>
            <pre> 
            '-'.join([x.strip().capitalize() for x in "thomas manure heap".split('manure')])
            //    'Thomas-Heap'
            </pre>
            </dd>   
            <dd>
            <pre> 

        '1,2,3'.split(',')                //     ['1', '2', '3']
        '1,2,3'.split(',', maxsplit=1)    //     ['1', '2,3']
        '1,,2,3'.split(None)              //     ['1,,2,3']
        '1,2,,3'.split()                  //     ['1,2,,3']

            </pre>
            </dd>   
            <dt>Reverse string</dt>
            <dd>   
            <pre>
    "Hello"
    x[::-1]  // "olleH"
            </pre>
            </dd>   

            <dt><code>str.join(iterable)</code></dt>

            <dd>Return a string which is the concatenation of the strings in
            <code>iterable</code>.</dd>
            <dd>A <code>TypeError</code> will be raised if there are any non-string
            values in <code>iterable</code>, including <code>bytes</code> objects.</dd>   
            <dd>The separator between elements is the string providing this method</dd>
            <dd>Concatenating immutable sequences always results in a new object.</dd>
            <dd>This means that building up a sequence by repeated concatenation
            will have a quadratic runtime cost in the total sequence length.</dd> 
            <dd>To get a linear runtime cost, you can build a list and use
            <code>str.join()</code> at the end</dd>
            <dd>
            <pre> 
             '-'.join([x.capitalize() for x in ["Tom", "dick", "harry"]])
             //    'Tom-Dick-Harry'
            </pre>  
            </dd>   

            <dd>
            <code>str.replace(old, new[, count])</code>
            </dd>

            <dd>Return a copy of the string with all occurrences of substring
            <code>old</code> replaced by <code>new</code>.</dd> 
            <dd>If the optional argument <code>count</code> is given, only the
            first count occurrences are replaced.</dd>
            <dd><pre> 

    str="tom is a man and tom is a coder"
    str.replace('is', 'was')     //     'tom was a man and tom was a coder'
    str.replace('is', 'was',1)   //     'tom was a man and tom is a coder'

            </pre></dd>   

            <dt><code>str.endswith(suffix[, start[, end]])</code></dt>

            <dd>Return <code>True</code> if the string ends with the specified
            suffix, otherwise return <code>False</code>.</dd> 
            <dd><code>suffix</code> can also be a <mark>tuple of suffixes</mark>
            to look for.</dd> 
            <dd>With optional <code>start</code>, test beginning at that position. </dd>               <dd>With optional <code>end</code>, stop comparing at that position.</dd>

            <dt><code>str.format(*args, **kwargs)</code></dt> 

            <dd>Perform a string formatting operation.</dd> 
            <dd>The string on which this method is called can contain literal text
            or replacement fields delimited by braces <code>{}</code>.</dd> 
            <dd>Each replacement field contains either the <mark>numeric index of
              a positional argument</mark>, or the
            <code>name of a keyword argument</code>.</dd> 
            <dd>Returns a copy of the string where each replacement field is
            replaced with the string value of the corresponding argument.</dd>

            <dd><pre> 

    "hello {}, how are you {}".format('joe', 'today')
    'hello joe, how are you today'

    "hello {1}, how are you {0}".format('joe', 'today')
    'hello today, how are you joe'

    "hello {fname}, how are you {day}".format(fname="joe", day="today")
    'hello joe, how are you today'

    "hello {2}, how are you {1}".format('joe', 'today')
    //  Traceback (most recent call last):
    //    File "&lt;pyshell#1&gt;", line 1, in &lt;module&gt;
    //    "hello {2}, how are you {1}".format('joe', 'today')
    //    IndexError: Replacement index 2 out of range for positional args tuple

            </pre></dd>   

            <dt><code>str.partition(sep)</code></dt>

            <dd>Split the string at the first occurrence of <code>sep</code>,
            and <mark>return a 3-tuple</mark> containing the part before the
            separator, the separator itself, and the part after the separator.
            </dd> 
            <dd>If the separator is not found, return a 3-tuple containing the
            string itself, followed by two empty strings.</dd>
            <dd><pre> 
    "thomas".partition('m')     //     ('tho', 'm', 'as')
    "thomas".split('m')         //     ['tho', 'as']
    "assassin".partition('s')   //     ('a', 's', 'sassin')
            </pre></dd>   

            <dt><code>str.startswith(prefix[, start[, end]])</code></dt>

            <dd>Return <code>True</code> if string starts with the
            <code>prefix</code>, otherwise return <code>False</code>.</dd>
            <dd><code>prefix</code> can also be a tuple of prefixes to look for.</dd>
            <dd>With optional <code>start</code>, test string beginning at that position.</dd> 
            <dd>With optional <code>end</code>, stop comparing string at that
            position.</dd>

            <dt><code>str.zfill(width)</code></dt> 

            <dd>The <code>zfill()</code> method adds zeros <code>(0)</code> at the
 beginning of the string, until it reaches the specified length.</dd>

            <dd>Return a copy of the string left filled with ASCII <code>'0'</code>
            digits to make a string of length width.</dd> 

            <dd>A leading sign prefix <code>('+'/'-')</code> is handled by
            inserting the padding after the sign character rather than before.</dd> 

            <dd>The original string is returned if <code>width</code> is less than
            or equal to <code>len(s)</code>.</dd>
          </dl>
        </details>
      </div>

      <div class="examples">
        <details><!--begin-outer-details-->
          <summary>Examples</summary>
          <details><!--inner-->
            <summary>Example 1</summary>
            <pre>

     "thomas".index('o')    //    2
     "thomas".find('o')     //    2
     "thomas".find('z')     //   -1
     "thomas".index('z')    //    ValueError: substring not found
     r"thomas\t\n"          //    'thomas\\t\\n'
     "thomas".isalpha()     //    True
     "thomas1".isalpha()    //    False
     "123".isdigit()        //    True

            </pre>
          </details><!--inner-->
          <details><!--inner-->
            <summary>Not always immutable example 2</summary>
            <pre>
    a="Hello"
    id(a)     //  2619781261936
    a+="!"
    id(a)    //   2619741244400    // Same-1
    a+="!"
    id(a)    //   2619741244400    // Same-2
            </pre>
          </details><!--inner-->
          <details><!--inner-->
            <summary>Not always immutable example 3</summary>
            <pre>
            id(tom)    //   1562971712240
            tom+="th"
            id(tom)    //   1562970986736  // change
            tom+="er"
            id(tom)    //   1562970986736  // no change !!
            tom+="e"
            id(tom)    //   1562970986736  // no change !!
            tom        //   'hellothere'
            </pre>
          </details><!--inner-->
        </details><!--end-outer-details-->
      </div>
      <div class="notes">
        <details>
          <summary>Notes</summary>
          <dl>
            <dt>Python strings are immutable, but only sometimes</dt>
            <dd>
            <p>See Ref below!</p>                                   
            </dd>
            <dt>References</dt>

            <dd>
            <p>
            <a href ="https://www.tutorialspoint.com/python_text_processing/python_string_immutability.htm">
              Python - String Immutability</a>
            </p>
            </dd>

            <dd>
            <p>
            <a href ="https://web.eecs.utk.edu/~azh/blog/pythonstringsaremutable.html">
              Austin Z. Henley: Python strings are immutable, but only sometimes
            </a>
            </p>
            </dd>

            <dd>                                                     
            <p> 
            <a href ="https://docs.python.org/3/library/stdtypes.html#str">
              str
            </a>
            </p>  
            </dd>

            <dd>                                                     
            <p> 
            <a href ="https://docs.python.org/3/library/stdtypes.html#string-methods">
              string methods
            </a>
            </p>  
            </dd>

            <dd>
            <p>
            <a href ="https://stackoverflow.com/q/39675898/499167">
              Is python += string concatenation bad practice? (Stackoverflow)
            </a>
            </p>
            </dd>

            <dd>
            <p>
            <a href ="https://docs.python.org/3/library/stdtypes.html#string-methods">
              String Methods
            </a>
            </p>
            </dd>

            <dd>
            <p>
            <a href ="https://stackoverflow.com/a/4664889/499167">
              How to find all occurrences of a substring?
            </a>
            </p>
            </dd>

          </dl>
        </details>
      </div>
    </div>
  </body>

</html>
