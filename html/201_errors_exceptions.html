<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8" />
    <title>[errors]</title>
    <link rel="icon" href="http://xu/tgdfiles/icon/bonnie.ico" />
    <style>
div {
  color: black;
}
    </style>
  </head>

  <body>
    <div class="container">
      <header>
        Errors and Error Handling
      </header>
      <div class="counter">xx</div>
      <main>
        <dl>
          <dt>Errors</dt>
          <dd>[Main text]</dd>
          <dt>Syntax Errors</dt>
          <dd>Syntax errors, also known as parsing errors, are "where you do not
          write Python code properly"</dd>
          <dt>Exceptions</dt>
          <dd>Even if a statement or expression is syntactically correct, it may
          cause an error when an attempt is made to execute it.</dd> 
          <dd>Errors <em>detected during execution</em> are called
          <code>exceptions</code> and are not unconditionally fatal</dd>
          <dd>Most exceptions are not handled by programs and result in error messages</dd> 
          <dd>
          <pre>

    10 * (1/0)
    //  Traceback (most recent call last):
    //    File "&lt;stdin&gt;", line 1, in &lt;module&gt;
    //  ZeroDivisionError: division by zero

          </pre>
          </dd>

          <dt>Handling Exceptions</dt> 
          <dd>
          <pre>
    while True:
        try:
            x = int(input("Please enter a number: "))
            break
        except ValueError:
            print("Oops!  That was no valid number.  Try again...")
          </pre>
          </dd>

          <dd>The <code>try</code> statement works as follows.</dd>

          <dd>
          <ol>
            <li>First, the <code>try</code> clause (the statement(s) between the
              try and except keywords) is executed.</li>
            <li>If no exception occurs, the <code>except </code>clause is skipped
              and execution of the <code>try</code> statement is finished.</li>

            <li>If an exception occurs during execution of the <code>try</code>
              clause, the rest of the clause is skipped.</li>
            <li>Then <em>if its type matches</em> the exception named after the
              <code>except </code>keyword, the except <code>clause</code> is executed,
              and then execution continues after the <code>try</code> statement.</li>
            <li>If an exception occurs which does not match the exception named in
              the except clause, it is passed on to outer try statements</li> 
            <li>If no handler is found, it is an unhandled exception and execution
              stops with a message as shown above.</li>
          </ol>
          </dd>
          <dd> <code>&check; </code>A <code>try</code> statement may have more
          than one <code>except</code> clause, to specify handlers for different 
          exceptions.</dd>

          <dd> <code>&check; </code>At most one handler will be executed.</dd>

          <dd>Handlers only handle exceptions that occur in the corresponding try
          clause, not in other handlers of the same try statement</dd>

          <dd><code>&check; </code>An <code>except</code> clause may name multiple
          exceptions as a parenthesized tuple, for example:</dd>

          <dd>
          <code>
            except (RuntimeError, TypeError, NameError):
            pass
          </code>
          </dd>

          <dd>The <code>try … except</code> statement has an optional
          <code>else</code> clause, which, when present, must <em>follow</em>
          all <code>except</code> clauses.</dd> 
          <dd>It is useful for code that must be executed if the try clause does
          not raise an exception.</dd> 

          <dd><pre> 
    for arg in sys.argv[1:]:
    try:
        f = open(arg, 'r')
    except OSError:
        print('cannot open', arg)
    else:
        print(arg, 'has', len(f.readlines()), 'lines')
        f.close()
          </pre></dd>   
          <dd><code>else</code></dd>
          <dd>The use of the <code>else</code> clause is better than adding
          additional code to the <code>try</code> clause because it avoids accidentally
          catching an exception that wasn’t raised by the code being protected by
          the try … except statement.</dd>
          <dt>Exception argument</dt>
          <dd>When an exception occurs, it may have an associated value, also
          known as the exception’s <code>argument</code>.</dd>

          <dd>The presence and type of the argument depend on the exception type.</dd>
          <dd>The <code>except</code> clause may specify a variable after the
          exception name</dd>
          <dd>The variable is bound to an exception instance with the arguments
          stored in <code>instance.args</code>.</dd>
          <dd>For convenience, the exception instance defines <code>__str__()</code>
          so the arguments can be printed directly without having to reference
          <code>.args</code>
          </dd>   
          <dd>One may also instantiate an exception first before raising it and
          add any attributes to it as desired.</dd>
          <dd><pre>

    try:
        raise Exception('spam', 'eggs')
    except Exception as inst:
        print(type(inst))         //    &lt;class 'Exception'&gt;
        print(inst.args)          //    ('spam', 'eggs')
        print(inst)               //    ('spam', 'eggs')
                                  //    __str__ allows args to be printed directly
        x, y = inst.args
        print("x = ", x)          //    x = spam
        print("y = ", y)          //    y = eggs 
        print(str(inst.args))     //    ('spam', 'eggs')
        print(repr(inst.args))    //    ('spam', 'eggs')

          </pre></dd>
          <dd>If an exception has arguments, they are printed as the last part
          (‘detail’) of the message for unhandled exceptions.</dd>
          <dd>Exception handlers don’t just handle exceptions if they occur
          immediately in the <code>try</code> clause, but also
          <em>if they occur inside functions</em>
          that are called (even indirectly) in the try clause.</dd>

          <dt><code>raise</code>an exception</dt>

          <dd>The <code>raise</code> statement allows the programmer to force
          a specified exception to occur.</dd>
          <dd>For example</dd>

          <dd>
          <pre> 
    raise NameError('HiThere')

    //  Traceback (most recent call last):
    //    File "&lt;stdin&gt;", line 1, in &lt;module&gt;
    //  NameError: HiThere

          </pre></dd>   

          <dd>The sole argument to raise indicates the exception to be raised.</dd>
          <dd>This must be either an exception instance or an exception class
          (a class that derives from <code>Exception</code>).</dd>
          <dd>If an exception class is passed, it will be implicitly instantiated
          by calling its constructor with no arguments:</dd>
          <dd><pre>
    raise ValueError  # shorthand for 'raise ValueError()'
          </pre></dd>
          <dd>If you need to determine whether an exception was raised but don’t
          intend to handle it, a simpler form of the <code>raise</code> statement
          allows you to re-raise the exception:</dd>


          <dd><pre>  

    try:
        raise NameError('HiThere')
    except NameError:
        print('An exception flew by!')
        raise

    //    An exception flew by
    //    Traceback (most recent call last):
    //      File "tryme_temp.py", line 2, in &lt;module&gt;
    //        raise NameError('Hi There')
    //    NameError: Hi There

    # Contrast with

    try:        
        raise NameError('Hi There')
    except:
        print("An exception flew by")

    // An exception flew by

          </pre></dd>   
          <dt>Exception Chaining</dt>
          <dd>The <code>raise</code> statement allows an optional
          <code>from</code> which enables chaining exceptions.</dd> 
          <dd>For example</dd>
          <dd><pre> 
    # exc must be exception instance or None.

    raise RuntimeError from exc
          </pre></dd>   
          <dd><pre>

    def func():
        raise IOError

    try:
        func()
    except IOError as exc:
        raise RuntimeError('Failed to open database') from exc


    //    Traceback (most recent call last):
    //      File "chaining_exceptions.py", line 6, in &lt;module&gt;
    //        func()
    //      File "chaining_exceptions.py", line 2, in func
    //        raise IOError
    //    OSError

    //    The above exception was the direct cause of the following exception:

    //    Traceback (most recent call last):
    //      File "chaining_exceptions.py", line 8, in &lt;module&gt;
    //        raise RuntimeError('Failed to open database') from exc
    //    RuntimeError: Failed to open database

          </pre></dd>

          <dt>Disable Exception Chaining</dt>
          <dd>Exception chaining happens automatically when an exception is
          raised inside an <code>except</code> or <code>finally</code> section.</dd> 
          <dd>Exception chaining can be disabled by using 
          <code>from None</code> idiom:</dd>

          <dt><code>try</code></dt>

          <dd><pre>
    # One          
    try:
        open('database.sqlite')
    except OSError:
        print('There is an error')


    // There is an error

    # Two          
    try:
        open('database.sqlite')
    except OSError:
        print('There is an error')
        raise RuntimeError


    //    There is an error
    //    Traceback (most recent call last):
    //      File "../../../AppData/Local/Programs/Python/Python39/disable_chaining_exceptions.py", line 2, in &lt;module&gt;
    //        open('database.sqlite')
    //    FileNotFoundError: [Errno 2] No such file or directory: 'database.sqlite'

    //    During handling of the above exception, another exception occurred:

    //    Traceback (most recent call last):
    //      File "../../../AppData/Local/Programs/Python/Python39/disable_chaining_exceptions.py", line 5, in &lt;module&gt;
    //        raise RuntimeError
    //    RuntimeError

    # Three

    try:
        open('database.sqlite')
    except OSError:
        print('There is an error')
        raise RuntimeError from None

    //    There is an error
    //    Traceback (most recent call last):
    //      File "../disable_chaining_exceptions.py", line 5, in &lt;module&gt;
    //        raise RuntimeError from None
    //    RuntimeError

          </pre>
          </dd>

          <dt><code>finally</code></dt>
          <dd>The <code>try</code> statement has another optional clause which is
          intended to define clean-up actions that must be
          <em>executed under all circumstances</em></dd>   
          <dd>For example:</dd>

          <dd><pre>   
    try:                                               
        raise KeyboardInterrupt
    finally:
        print('Goodbye, world!')

    //    Goodbye, world!                        // !! NOTE finally executes BEFORE exception raised
    //    Traceback (most recent call last):
    //      File "../raise_keyboard.py", line 2, in &lt;module&gt;
    //        raise KeyboardInterrupt
    //    KeyboardInterrupt

          </pre></dd>   

          <dd> 
          <ol>  
            <li>If a <code>finally</code> clause is present, it will execute as the
              <em>last task</em> before the <code>try</code> statement completes.</li>

            <li>The <code>finally</code> clause runs whether or not the <code>try</code> statement produces an exception.</li> 
          </ol> 
          </dd>   

          <dd>The following points discuss more complex cases when an exception occurs:</dd>
          <dd>  
          <ol>  
            <li>If an exception occurs during execution of the try clause,
              the exception may be handled by an except clause.</li> 
            <li>If the exception is not handled by an except clause, the exception
              is re-raised <code>after</code> the <code>finally</code> clause
              has been executed.</li>

            <li>An exception could occur during execution of an <code>except</code>
              or <code>else</code> clause. Again, the exception is re-raised
              <em>after</em> the <code>finally</code> clause has been executed.</li>

            <li>If the <code>finally</code> clause executes a <code>break</code>,
              <code>continue</code> or <code>return</code> statement, exceptions are
              <em>not</em> re-raised.</li>

            <li>If the <code>try</code> statement reaches a <code>break</code>,
              <code>continue</code> or <code>return</code> statement, the
              <code>finally</code> clause will execute <em>just prior</em> to the
              <code>break</code>, <code>continue</code> or <code>return</code>
              statement’s execution.</li>

            <li>If a <code>finally</code> clause includes a <code>return</code> statement,
              the returned value will be the one from the <code>finally</code>
              clause’s <code>return</code> statement, <em>not</em> the value from
              the <code>try</code> clause’s <code>return</code> statement.</li>
          </ol> 
          </dd>   
          <dd><pre>

    def bool_return():
        try:
            return True
        finally:
            return False

    print(bool_return())

    //  False

          </pre></dd> 
          <dd>A better example</dd>
          <dd><pre>

def divide(x,y):
    try:
        result = x/y
    except ZeroDivisionError:
        print('Division by Zero!')
    else:
        print('result is: ', result)
    finally:
        print("Executing finally clause")

    // python console

    import divide_finally as d
    d.divide(2,3)
    //  result is:  0.6666666666666666         //   (i)  else
    //  Executing finally clause               //   (ii) finally

    d.divide(2,0)                        
    //  Division by Zero!                      //   (i)  except
    //  Executing finally clause               //   (ii) finally

    d.divide("2","1")
    //  Executing finally clause               //   (i) finally !!
    //  Traceback (most recent call last):     //   (ii) re-raise exception
    //    File "&lt;stdin&gt;", line 1, in &lt;module&gt;
    //    File "C:\Users\thoma\AppData\Local\Programs\Python\Python39\divide_finally.py", line 3, in divide
    //      result = x/y
    //  TypeError: unsupported operand type(s) for /: 'str' and 'str'


          </pre></dd>

          <dt><code>with</code> statement and cleanup</dt>

          <dd>Some objects define standard clean-up actions to be undertaken when
          the object is no longer needed, regardless of whether or not the
          operation using the object succeeded or failed.</dd> 

          <dd><pre> 
    for line in open("myfile.txt"):
        print(line, end="")
          </pre></dd>   
          <dd>The problem with this code is that it leaves the file open for an
          indeterminate amount of time after this part of the code has finished
          executing.</dd> 
          <dd>This is not an issue in simple scripts, but can be a problem for larger applications.</dd> 

          <dd>The <code>with</code> statement allows objects like files to be
          used in a way that ensures they are always cleaned up promptly and correctly.</dd>
          <dd>  <pre> 
    with open("myfile.txt") as f:
    for line in f:
        print(line, end="")
          </pre>  </dd>   
          <dd>After the statement is executed, the file <code>f</code> is always
          closed, even if a problem was encountered while processing the lines.</dd>
          <dt>Built-in Exceptions</dt>

          <dd>In Python, all exceptions must be instances of a class that derives
          from <code>BaseException</code></dd>
          <dd>The built-in exceptions listed below can be generated by the
          interpreter or built-in functions.</dd> 
          <dd>Except where mentioned, they have an <code>associated value</code>
          indicating the detailed cause of the error.</dd>

          <dd>This may be a string or a tuple of several items of information
          (e.g., an error code and a string explaining the code).</dd> 
          The base class for those built-in exceptions that are raised for various arithmetic errors: OverflowError, ZeroDivisionError, FloatingPointError       <dd>The <code>associated value</code> is usually <em>passed as arguments</em>
          to the exception class’s constructor.</dd>

          <dd>Programmers are encouraged to derive new exceptions from the
          <code>Exception</code> class or one of its subclasses, and not from
          <code>BaseException</code></dd>

          <dt><code>exception BaseException</code></dt>

          <dd>The base class for all built-in exceptions.</dd> 
          <dd>It is not meant to be directly inherited by user-defined classes
          (for that, use <code>Exception</code>).</dd> 
          <dd>If <code>str()</code> is called on an instance of this class,
          the representation of the argument(s) to the instance are returned,
          or the empty string when there were no arguments.</dd>

          <dt><code>exception Exception</code></dt>                                                                                           
          <dd>All built-in, non-system-exiting exceptions are derived from this class.</dd>
          <dd>All user-defined exceptions should also be derived from this class.</dd>

          <dt><code>exception ArithmeticError</code></dt>

          <dd>
          The base class for those built-in exceptions that are raised for
          various arithmetic errors: <code>OverflowError</code>,
          <code>ZeroDivisionError</code>, <code>FloatingPointError</code>
          </dd>

          <dt><code>exception LookupError</code></dt>

          <dd>The base class for the exceptions that are raised when a key or index used on a mapping or sequence is invalid: <code>IndexError</code>, <code>KeyError</code>.</dd>

          <dt><code>exception IndexError</code></dt>

          <dd>Raised when a sequence subscript is out of range.</dd> 
          <dd>(Slice indices are silently truncated to fall in the allowed range;
          if an index <em>is not an integer</em>, <code>TypeError</code> is raised.)</dd>

          <dt><code>exception KeyError</code></dt>
          <dd>Raised when a mapping (dictionary) key is not found in the set of
          existing keys.</dd>

          <dt><code>exception KeyboardInterrupt</code></dt>
          <dd>Raised when the user hits the interrupt key
          (normally <code>Control-C</code> or <code>Delete</code>).</dd> 
          <dd>During execution, a check for interrupts is made regularly.</dd> 
          <dd>The exception inherits from <code>BaseException</code> so as to not
          be accidentally caught by code that catches <code>Exception</code> and
          thus prevent the interpreter from exiting.</dd>

          <dt><code>exception NameError</code></dt>
          <dd>Raised when a local or global name is not found.</dd> 
          <dd>This applies only to unqualified names.</dd>
          <dd>The associated value is an error message that includes the name
          that could not be found.</dd>
          <dd><code>exception SyntaxError(message, details)</code></dd>
          <dd>Raised when the parser encounters a syntax error.</dd> 
          <dd>This may occur in an <code>import</code> statement, in a call to
          the built-in functions <code>compile()</code>, <code>exec()</code>,
          or <code>eval()</code>, or when reading the initial script or standard
          input (also interactively).</dd>
          <dd>The <code>str()</code> of the exception instance returns only the
          error message.</dd> 
          <dd>Details is a tuple whose members are also available as separate
          attributes.</dd>

          <dt><code>exception IndentationError</code></dt>
          <dd>Base class for syntax errors related to incorrect indentation.</dd> 
          <dd>This is a subclass of <code>SyntaxError</code>.</dd>

  <dt><code>exception TypeError</code></dt>

  <dd>Raised when an operation or function is applied to an object <code>of inappropriate type</code></dd>
  <dd>The associated value is a string giving details about the type mismatch.</dd>
  <dd>This exception may be raised by user code to indicate that an
 attempted operation on an object is not supported, and is not meant
 to be</dd>

  <dd>Passing arguments of the <em>wrong type</em> (e.g. passing a list
 when an int is expected) <em>should result</em> in a <code>TypeError</code></dd>

  <dd>But passing arguments with the <em>wrong value</em> (e.g. a number
 outside expected boundaries) <em>should result</em> in a <code>ValueError</code>.</dd>

 <dd><code>exception ValueError</code></dd>
 <dd>Raised when an operation or function receives an argument that has the <em>right type</em> but an <em>inappropriate value</em>,</dd> 
 <dd>&hellip;and the situation is not described by a more precise exception such as <code>IndexError</code></dd>

 <dd><code>exception ZeroDivisionError</code></dd>

 <dd>Raised when the second argument of a division <em>or</em> modulo operation is zero.</dd> 
 <dd>The associated value is a string indicating the type of the operands and the operation</dd>

          <dd>
          <pre>
    try:
        # Runs first
    except:
        # Runs in exception in try block
    else:
        # Runs if try block SUCCEEDS
    finally:
        # Always executes 


          </pre>

          </dd>
        </dl>
      </main>
      <div class="syntax">
        <details>
          <summary>Syntax</summary>
          <pre>
          Syntax One
          </pre>
        </details>
      </div>
      <div class="examples">
        <details><!--begin-outer-details-->
          <summary>Examples</summary>
          <details><!--inner-->
            <summary>Example 1 Socratica logging example</summary>
            <pre>

        import logging
        import time

        # Create logger
        logging.basicConfig(filename="C:\\Users\\thoma\\ecollege/98_381_python\\11_topic\\problems.log", level = logging.DEBUG)

        logger = logging.getLogger()

        def read_file_timed(path):
            """Return the contents of the file at 'path' and measure the time required"""
            start_time = time.time()
            try:
                f = open(path, mode='rb')
                data = f.read()
                return data
            except FileNotFoundError as err:
                logger.error(err)
                raise
            else:
                f.close()
            finally:
                stop_time = time.time()
                dt=stop_time - start_time
                logger.info("Time required for {file} = {time}".format(file=path, time=dt))

        # data=read_file_timed("C:\\Users\\thoma\\ecollege\\98_381_python\\11_topic\\symphony_no_6.wav")
        data=read_file_timed("C:\\Users\\thoma\\ecollege\\98_381_python\\11_topic\\imaginary.wav")

        // problems.log (final)


    INFO:root:Time required for C:\Users\thoma\ecollege\98_381_python\11_topic\symphony_no_6.wav = 0.05799055099487305
    ERROR:root:[Errno 2] No such file or directory: 'C:\\Users\\thoma\\ecollege\\98_381_python\\11_topic\\imaginary.wav'
    INFO:root:Time required for C:\Users\thoma\ecollege\98_381_python\11_topic\imaginary.wav = 0.0010020732879638672

            </pre>
          </details><!--inner-->
        </details><!--end-outer-details-->
      </div>
      <div class="notes">
        <details>
          <summary>Notes</summary>
          <dl>
            <dt>References</dt>

            <dd>
            <p>
            <a href ="https://docs.python.org/3/tutorial/errors.html">
              Errors and Exceptions (Python Tutorial)
            </a>
            </p>
            </dd>

            <dd>
            <p>
            <a href ="https://www.youtube.com/watch?v=nlCKrKGHSSk&t=511s">
              Python Errors (Socratica, YouTube)
            </a>
            </p>
            </dd>

            <dd>
            <p>
            <a href ="https://stackoverflow.com/q/855759/499167">
              SO: Python try-else
            </a>
            </p>
            </dd>

            <dd>
            <p>
            <a href ="https://docs.python.org/3/library/exceptions.html#bltin-exceptions">
              Built-in Exceptions (Python Docs)
            </a>
            </p>
            </dd>
          </dl>
        </details>
      </div>
    </div>
  </body>
  <html>
